# 阶段三：Puppeteer 高保真视频渲染方案

## 问题背景

在 `feat/browser-recording-v1` 分支中，我们尝试了基于 `html2canvas` 和 `MediaRecorder` 的浏览器端录制方案（方案 A）。然而，测试结果表明该方案存在严重缺陷：

*   **样式丢失**: 录制的视频无法准确捕捉到复杂的 CSS 样式。
*   **动效失效**: CSS `transform` 和 `transition` 等动画效果在最终的视频中完全丢失。

这导致最终成品质量不达标，因此我们决定废弃该方案，寻求一种能够 **100% 还原浏览器视觉效果** 的高保真方案。

## 方案讨论与决策

我们重新评估了 `task2.md` 中提出的服务器端方案，并进行了深入讨论。

### 方案 B: 纯服务器端渲染 (FFmpeg)

*   **核心思想**: 在后端通过代码动态生成复杂的 FFmpeg 命令，从零开始合成每一帧视频。
*   **优点**: 性能高，输出稳定。
*   **缺点**: 复杂度极高，需要用 FFmpeg 的滤镜语法在后端重写所有前端的视觉效果（布局、动画、样式），开发和维护成本巨大，且无法做到“所见即所得”。

### 方案 C: 无��浏览器自动化 (Puppeteer)

*   **核心思想**: 在服务器上用程序控制一个无头浏览器（Chrome）来访问我们的 Vue 应用，让它播放动画，同时进行逐帧截图，最后用 FFmpeg 将截图序列合成为视频。
*   **优点**:
    *   **完美所见即所得**: 视频效果与浏览器预览完全一致。
    *   **逻辑复用**: 无需重写渲染逻辑，所有视觉效果依然由 Vue 和 CSS 负责。
    *   **维护简单**: 未来调整视觉效果只需修改前端代码。
*   **缺点**: 资源消耗较大，渲染速度相对较慢。

### 最终决策

我们一致认为，**方案 C (Puppeteer) 是当前最合适的选择**。它的“所见即所得”和“低维护成本”的优势是决定性的，可以完美复用我们已有的前端成果。

同时，我们进一步简化了该方案的架构：**放弃创建一个常驻的 Express 后端服务，而是实现一个独立的、按需运行的 Node.js 脚本**，把它当作一个命令行构建工具来使用。

## 实施计划

我们确定了以下实施步骤：

1.  **切换回 `main` 分支**，在一个干净的环境上开始工作。
2.  **安装依赖**: 安装 `puppeteer` 用于浏览器自动化，以及 `ts-node` 以便能直接用 TypeScript 编写脚本。
3.  **创建渲染脚本 (`scripts/render.ts`)**:
    *   该脚本包含所有 Puppeteer 和 FFmpeg 的调用逻辑。
    *   在脚本顶部提供清晰的配置项，如 `url`, `viewport`, `fps` 等。
4.  **建立通信桥梁**:
    *   **前端修改**: 修改 `App.vue`，在动画播放完成时，调用一个挂载在 `window` 对象上的全局函数（如 `window.onAnimationComplete()`）。
    *   **脚本注入**: Puppeteer 脚本通过 `page.exposeFunction` 向页面注入 `onAnimationComplete` 函数的实现，从而接收来自前端的完成信号。
5.  **核心录制流程**:
    *   脚本启动，创建临时文件夹 `temp_frames/`。
    *   Puppeteer 打开指定 URL。
    *   脚本通过代码“点击”播放按钮，并开始以固定间隔（如 30fps）循环截图，存入临时文件夹。
    *   等待前端通过 `onAnimationComplete` 发出完成信号。
    *   收到信号后，停止截图，关闭浏览器。
6.  **视频合成**:
    *   脚本调用本地 `ffmpeg` 命令，将 `temp_frames/` 中的图片序列合成为一个 `output.mp4` 文件。
7.  **清理**: 视频生成后，自动删除 `temp_frames/` 临时文件夹。
8.  **配置 `package.json`**:
    *   在 `scripts` 中添加一个 `"render:video": "node --loader ts-node/esm scripts/render.ts"` 命令，方便一键启动。

这个方案将视频渲染过程解耦成了一个简单、独立的命令行工具，实现了我们的目标。
